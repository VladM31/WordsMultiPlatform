<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Words</title>
    <link rel="icon" type="image/webp" href="icon.webp">

    <script>
        window.__APP_VERSION__ = "20260301_003";
    </script>

    <!-- Preconnect for Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <!-- Noto Sans Symbols2 provides broader symbol coverage (arrow glyphs etc.) -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Symbols2&display=swap"
          rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Sans&display=swap">
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            box-sizing: border-box;
            /* Add symbol-supporting font as a fallback for web so characters like ⮕ and ⬅ render */
            font-family: 'Noto Sans Symbols2', 'Noto Sans JP', 'Noto Sans', 'Segoe UI Symbol', 'Segoe UI', system-ui, -apple-system, 'Segoe UI Emoji', 'Apple Color Emoji', sans-serif;
        }

        * {
            box-sizing: border-box;
        }

        /* Loading screen styles */
        #app-loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #2C3039 0%, #323744 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease-out;
        }

        #app-loader.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loader-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid #2C3039;
            border-top: 4px solid #44F2C1;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }

        .loader-text {
            margin-top: 24px;
            color: #ffffff;
            font-size: 18px;
            font-weight: 500;
            text-align: center;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.6;
            }
        }

        .loader-subtitle {
            margin-top: 8px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            text-align: center;
        }

        .loader-progress-bar {
            width: 200px;
            height: 4px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 2px;
            margin-top: 20px;
            display: none;
            overflow: hidden;
        }

        .loader-progress-fill {
            height: 100%;
            width: 0%;
            background: #44F2C1;
            border-radius: 2px;
            transition: width 0.2s ease-out;
        }
    </style>
    <!-- Initialize placeholder Firebase object before composeApp loads -->
    <script>
        window._firebaseEventQueue = [];
        window.firebaseAnalytics = {
            logEvent: function (eventName, params) {
                console.log('Firebase pending logEvent:', eventName, params);
                window._firebaseEventQueue.push({type: 'event', eventName, params});
            },
            setUserId: function (userId) {
                console.log('Firebase pending setUserId:', userId);
                window._firebaseEventQueue.push({type: 'userId', userId});
            },
            setUserProperties: function (properties) {
                console.log('Firebase pending setUserProperties:', properties);
                window._firebaseEventQueue.push({type: 'properties', properties});
            }
        };
    </script>

    <script type="module">
        // Import the functions you need from the SDKs you need
        import {initializeApp} from "https://www.gstatic.com/firebasejs/12.8.0/firebase-app.js";
        import {
            getAnalytics,
            logEvent,
            setUserId,
            setUserProperties
        } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-analytics.js";
        import {
            getAuth,
            signInWithPopup,
            signOut,
            GoogleAuthProvider
        } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-auth.js";

        // Your web app's Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyAdiBvkaPLN_HHoRb4TxtE9jyp3lKnW4Ws",
            authDomain: "words-53d45.firebaseapp.com",
            projectId: "words-53d45",
            storageBucket: "words-53d45.firebasestorage.app",
            messagingSenderId: "1005445939198",
            appId: "1:1005445939198:web:d4405546c35cbf741c8aaf",
            measurementId: "G-53L6PK51VB"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const analytics = getAnalytics(app);
        const auth = getAuth(app);
        const googleProvider = new GoogleAuthProvider();
        googleProvider.addScope('email');
        googleProvider.addScope('profile');
        console.log('Firebase Analytics initialized');
        console.log('Firebase Auth initialized');

        // Google Sign-In functions
        window.isGoogleSignInAvailable = () => {
            return true; // Firebase Auth is available on web
        };

        window.signInWithGoogle = async () => {
            try {
                const result = await signInWithPopup(auth, googleProvider);
                const user = result.user;

                // Get the Google OAuth credential (contains the real Google ID Token)
                const credential = GoogleAuthProvider.credentialFromResult(result);
                // This is the Google ID Token that can be verified with GoogleIdTokenVerifier
                const googleIdToken = credential?.idToken || null;

                // Fallback to Firebase ID Token if Google credential not available
                const firebaseIdToken = await user.getIdToken();

                return {
                    success: true,
                    // Prefer Google ID Token for backend verification
                    idToken: googleIdToken || firebaseIdToken,
                    googleIdToken: googleIdToken,
                    firebaseIdToken: firebaseIdToken,
                    email: user.email || '',
                    userId: user.uid,
                    displayName: user.displayName || ''
                };
            } catch (error) {
                console.error('Google Sign-In error:', error);
                let errorMessage = error.message || 'Unknown error';

                if (error.code === 'auth/popup-closed-by-user') {
                    errorMessage = 'Sign-in cancelled';
                } else if (error.code === 'auth/network-request-failed') {
                    errorMessage = 'Network error. Please check your connection.';
                } else if (error.code === 'auth/popup-blocked') {
                    errorMessage = 'Popup was blocked. Please allow popups for this site.';
                }

                return {
                    success: false,
                    error: errorMessage
                };
            }
        };

        window.signOutFromGoogle = async () => {
            try {
                await signOut(auth);
                return {success: true};
            } catch (error) {
                console.error('Sign-out error:', error);
                return {success: false, error: error.message};
            }
        };

        window.getCurrentGoogleUser = () => {
            const user = auth.currentUser;
            if (user) {
                return {
                    email: user.email || '',
                    userId: user.uid,
                    displayName: user.displayName || ''
                };
            }
            return null;
        };

        // Replace placeholder with real Firebase Analytics
        window.firebaseAnalytics = {
            logEvent: (eventName, params) => {
                console.log('Firebase logEvent:', eventName, params);
                logEvent(analytics, eventName, params);
            },
            setUserId: (userId) => {
                console.log('Firebase setUserId:', userId);
                setUserId(analytics, userId);
            },
            setUserProperties: (properties) => {
                console.log('Firebase setUserProperties:', properties);
                setUserProperties(analytics, properties);
            }
        };

        // Process queued events
        if (window._firebaseEventQueue && window._firebaseEventQueue.length > 0) {
            console.log('Processing', window._firebaseEventQueue.length, 'queued Firebase events');
            window._firebaseEventQueue.forEach(item => {
                switch (item.type) {
                    case 'event':
                        window.firebaseAnalytics.logEvent(item.eventName, item.params);
                        break;
                    case 'userId':
                        window.firebaseAnalytics.setUserId(item.userId);
                        break;
                    case 'properties':
                        window.firebaseAnalytics.setUserProperties(item.properties);
                        break;
                }
            });
            window._firebaseEventQueue = null;
        }
    </script>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script>
        // Global variables for Telegram auth data (read by Kotlin via getTgInitData / getTgUserJson)
        window.TG_INIT_DATA = "";
        window.TG_USER_JSON = "";

        (function () {
            try {
                const tg = window.Telegram && window.Telegram.WebApp;
                if (tg) {
                    window.TG_INIT_DATA = tg.initData || "";
                    window.TG_USER_JSON = JSON.stringify(tg.initDataUnsafe || {});
                    try {
                        tg.ready();
                    } catch (e) {
                        console.warn('tg.ready() failed', e);
                    }
                    try {
                        tg.expand();
                    } catch (e) {
                        console.warn('tg.expand() failed', e);
                    }
                } else {
                    console.log('Telegram WebApp not available (running outside Telegram).');
                }
            } catch (e) {
                console.error('Telegram WebApp init error:', e);
            }
        })();

        window.getTgInitData = function () {
            return window.TG_INIT_DATA || "";
        };
        window.getTgUserJson = function () {
            return window.TG_USER_JSON || "";
        };
        window.openTelegramLink = function (url) {
            try {
                const tg = window.Telegram && window.Telegram.WebApp;
                if (tg) {
                    if (typeof tg.openTelegramLink === 'function') {
                        try {
                            tg.openTelegramLink(url);
                            return true;
                        } catch (e) {
                            console.warn('openTelegramLink failed', e);
                        }
                    }
                    if (typeof tg.openLink === 'function') {
                        try {
                            tg.openLink(url);
                            return true;
                        } catch (e) {
                            console.warn('openLink failed', e);
                        }
                    }
                }
                try {
                    window.open(url, '_blank');
                    return true;
                } catch (e) {
                    console.warn('window.open failed', e);
                }
            } catch (e) {
                console.error('openTelegramLink error:', e);
            }
            return false;
        };

        // Android keyboard fix for Compose Web inside Telegram Mini App.
        //
        // ROOT CAUSE: Telegram Android WebView requires at least one successful
        // "input activation" before it allows programmatic focus() on text inputs.
        // Tapping a <select> element grants this token for the entire session.
        // That's why all inputs start working after the user opens SingleSelectInput.
        //
        // FIX: On the very first touchstart we programmatically click a hidden
        // <select> element (positioned off-screen so no popup appears) and then
        // immediately close it. This grants the keyboard token silently.
        // After that, every subsequent focus() on text inputs works normally.
        (function () {
            if (!/Android/i.test(navigator.userAgent)) return;

            let dummyInput = null;
            let dummySelect = null;
            let focusObserver = null;
            let keyboardWarmedUp = false;

            function getDummy() {
                if (dummyInput) return dummyInput;
                dummyInput = document.createElement('input');
                dummyInput.type = 'text';
                dummyInput.setAttribute('aria-hidden', 'true');
                dummyInput.setAttribute('tabindex', '-1');
                dummyInput.setAttribute('autocomplete', 'off');
                dummyInput.setAttribute('autocorrect', 'off');
                dummyInput.setAttribute('autocapitalize', 'off');
                dummyInput.setAttribute('spellcheck', 'false');
                dummyInput.readOnly = false;
                dummyInput.style.cssText =
                    'position:fixed;top:0;left:0;width:1px;height:1px;' +
                    'opacity:0.01;border:none;padding:0;margin:0;outline:none;' +
                    'pointer-events:none;z-index:-1;' +
                    'color:transparent;background:transparent;caret-color:transparent;' +
                    'font-size:16px;';
                (document.body || document.documentElement).appendChild(dummyInput);
                return dummyInput;
            }

            function getDummySelect() {
                if (dummySelect) return dummySelect;
                dummySelect = document.createElement('select');
                // A <select> must have at least one option to be clickable
                var opt = document.createElement('option');
                opt.value = '';
                opt.textContent = '';
                dummySelect.appendChild(opt);
                // Place it off-screen but keep it technically visible (display:none prevents click)
                dummySelect.style.cssText =
                    'position:fixed;top:-9999px;left:-9999px;width:1px;height:1px;' +
                    'opacity:0.01;border:none;padding:0;margin:0;outline:none;' +
                    'font-size:16px;z-index:-1;pointer-events:none;';
                (document.body || document.documentElement).appendChild(dummySelect);
                return dummySelect;
            }

            // Click a hidden <select> and instantly blur it.
            // This is the exact mechanism that grants keyboard token in Telegram WebView.
            function warmUpKeyboard() {
                if (keyboardWarmedUp) return;
                keyboardWarmedUp = true;
                try {
                    var sel = getDummySelect();
                    sel.style.pointerEvents = 'auto';
                    sel.focus();
                    sel.dispatchEvent(new MouseEvent('mousedown', {bubbles: true, cancelable: true}));
                    sel.dispatchEvent(new MouseEvent('mouseup', {bubbles: true, cancelable: true}));
                    sel.dispatchEvent(new MouseEvent('click', {bubbles: true, cancelable: true}));
                    // Immediately blur — prevents any native picker from opening
                    sel.blur();
                    sel.dispatchEvent(new Event('blur', {bubbles: true}));
                    sel.style.pointerEvents = 'none';
                } catch (e) { /* ignore */
                }
                // Also do the text input focus cycle as a second layer
                try {
                    var dummy = getDummy();
                    dummy.readOnly = false;
                    dummy.focus();
                    dummy.dispatchEvent(new InputEvent('input', {bubbles: true, data: ''}));
                    dummy.blur();
                    dummy.focus();
                } catch (e) { /* ignore */
                }
            }

            function findSkikoInput() {
                const inputs = document.querySelectorAll(
                    'input:not([aria-hidden="true"]):not([tabindex="-1"]), ' +
                    'textarea:not([aria-hidden="true"])'
                );
                for (let i = 0; i < inputs.length; i++) {
                    if (inputs[i] !== dummyInput) return inputs[i];
                }
                return null;
            }

            function focusSkikoInput() {
                const el = findSkikoInput();
                if (el) {
                    el.focus();
                    el.click();
                    return true;
                }
                return false;
            }

            function startObserver() {
                if (focusObserver) focusObserver.disconnect();
                const deadline = Date.now() + 1500;
                focusObserver = new MutationObserver(function (mutations, obs) {
                    if (Date.now() > deadline) {
                        obs.disconnect();
                        return;
                    }
                    if (focusSkikoInput()) obs.disconnect();
                });
                focusObserver.observe(document.documentElement, {
                    childList: true,
                    subtree: true,
                    attributes: true,
                    attributeFilter: ['style', 'class', 'tabindex', 'aria-hidden', 'readonly']
                });
                setTimeout(function () {
                    if (focusObserver) {
                        focusObserver.disconnect();
                        focusObserver = null;
                    }
                }, 1500);
            }

            // touchstart — earliest possible gesture moment
            document.addEventListener('touchstart', function (e) {
                // Warm up keyboard token on very first touch using hidden <select>
                warmUpKeyboard();
                getDummy().focus();
                focusSkikoInput();
            }, {passive: true});

            // touchend — Skiko may have created its input by now
            document.addEventListener('touchend', function (e) {
                getDummy().focus();
                if (focusSkikoInput()) return;
                startObserver();
            }, {passive: true});
        })();
    </script>
</head>
<body>
<div id="app-loader">
    <div class="loader-spinner"></div>
    <div class="loader-text">Loading Words...</div>
    <div class="loader-subtitle" id="loader-subtitle">Preparing your learning experience</div>
    <div class="loader-progress-bar" id="loader-progress-bar">
        <div class="loader-progress-fill" id="loader-progress-fill"></div>
    </div>
</div>

<script>
    // Called by Kotlin main() when the app is ready
    window.hideAppLoader = function () {
        const loader = document.getElementById('app-loader');
        if (!loader) return;
        loader.classList.add('hidden');
        setTimeout(function () {
            loader.remove();
        }, 500);
    };

    const appVersion = window.__APP_VERSION__ || 'dev';
    const script = document.createElement('script');
    script.type = 'application/javascript';
    script.src = `composeApp.js?v=${appVersion}`;
    script.onerror = function () {
        console.error('Failed to load composeApp.js');
        const loader = document.getElementById('app-loader');
        if (loader) {
            loader.innerHTML = '<div style="padding:20px;font-family:sans-serif;color:#fff;text-align:center;">' +
                '<div style="font-size:48px;margin-bottom:16px;">⚠️</div>' +
                '<div style="font-size:20px;margin-bottom:8px;">Failed to load application</div>' +
                '<div style="font-size:14px;opacity:0.8;">Please refresh the page or check your connection</div>' +
                '</div>';
        }
    };
    script.onload = function () {
        console.log('composeApp.js loaded');
    };
    document.head.appendChild(script);
</script>

</body>
</html>
